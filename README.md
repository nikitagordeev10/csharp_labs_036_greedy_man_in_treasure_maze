# Платформа: ulearn
## Курс: Основы программирования
### Тема: 27 Жадные алгоритмы
#### Практика «Путь в лабиринте»
##### Решено 29 октября 2023 в 17:13

На этот раз в лабиринт с сокровищами попал Жадина! Лабиринт очень старый и все свободные клетки успели покрыться зарослями. Для каждой клетки лабиринта известна её трудность — количество сил, которые потратит Жадина на прохождение зарослей этой клетки.

После каждого шага силы Жадины уменьшаются на трудность клетки, в которую он шагнул. Когда силы заканчиваются, Жадина останавливается.

Посмотреть на лабиринты можно запустив проект:
- Выбрать лабиринт можно в меню States слева сверху.
- Цифры и яркость на клетках — это трудность.

Жадина хочет узнать, какое минимальное количество сил ему нужно потратить чтобы дойти от текущей клетки до какого-то из сундуков. Причём, он ещё не решил, какой из сундуков он хочет посетить, так что Жадина хочет узнать кратчайшее расстояние до каждого из сундуков.

Поможем Жадине найти кратчайшие пути до каждого из сундуков!

В файле DijkstraPathFinder.cs реализуем метод GetPathsByDijkstra. Ему на вход поступают: лабиринт, начальная позиция Жадины, список целей — клеток, до которых нужно найти кратчайшие пути. Он должен возвращать пути до всех целей в виде IEnumerable в порядке увеличения трудности пути до них. При этом вычислять пути он должен лениво, то есть не вычислять пути до далёких сундуков и не обрабатывать весь лабиринт, пока это не запросили из IEnumerable.

Описание лабиринта передаётся в метод в объекте типа State:
- в поле CellCost находится двумерный массив трудностей всех клеток (0 означает стену).
- есть методы, которые помогут проверить, что какая-то клетка является стеной или находится внутри лабиринта.
- там же есть свойство Chests, но в данной задаче вместо него используйте список целей, переданный в метод аргументом.

Все тесты в классе DijkstraPathFinder_Should должны завершиться успехом.


Чтобы жизнь удалась, Жадине нужно собрать N сундуков. При этом, Жадина отказывается идти к сундуку, если есть другой сундук, путь до которого потребует меньше сил: он не только жадина, но и лентяй!

Помогите Жадине собрать N сундуков!

После выполнения этой задачи, Жадина начнёт передвигаться по лабиринту после запуска приложения.

Реализуем в файле GreedyPathFinder.cs метод FindPathToCompleteGoal. Он должен возвращать путь передвижения Жадины. Путь не должен содержать исходную позицию — ту из которой Жадина начинает движение. Если подходящего пути не существует, метод должен возвращать пустой список.

Текущее состояние уровня передается в метод в объекте типа State.

Используем класс DijkstraPathFinder, реализованный в предыдущей задаче. Его не нужно включать в отправляемый на проверку файл, считайте, что этот класс уже есть в проекте. При проверке этой задачи будет использоваться авторская реализация DijkstraPathFinder, а не ваша.

Гарантируется, что если рассмотреть множество всех сундуков и добавить в него исходную позицию, то в нём не существует тройки A, B, C, такой, что от А добраться до B так же трудно, как и от A до C. Другими словами, у Жадины всегда есть только один вариант дальнейших действий.

Тесты в классах GreedyPathFinder_Should и GreedyTimeLimit_Tests должны завершаться успехом.

